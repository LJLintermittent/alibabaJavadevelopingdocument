# 《阿里巴巴Java开发手册--部分重点摘录与分析》

## 第五章 MySQL数据库

### 建表规约

* 【强制】表达是与否的概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint(1表示是，0表示否)

  ~~~wiki
  说明：任何字段如果为非负数，则必须是unsigned
  注意：POJO类中的任何布尔类型的变量，都不要加is前缀，需要在<resultMap>中设置从is_xxx到xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围
  正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除
  ~~~

* 【强制】表名，字段名必须使用小写字母或数字，禁止出现数字开头，禁止是在两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑

  ~~~wiki
  说明：
  MySQL在windows系统中是不区分大小写的，但在Linux系统中默认区分大小写。因此，数据库名，表明，字段名都不允许出现任何大写字母，避免节外生枝
  ~~~

* 【强制】表名不使用复数名词

  ~~~wikii
  说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应到DO类也是单数形式
  ~~~

* 【强制】禁用保留字，如desc，range，match，delayed等，请参考MySQL官方保留字

* ~~~wiki
  【强制】主键索引名为pk_字段名，唯一索引名为uk_字段名，普通索引名为idx_字段名
  ~~~

* 【强制】小数类型为decimal，禁止使用float和double类型

  ~~~wiki
  说明：在存储时，float和double存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过decimal的范围，那么建议将数据拆成整数和小数并分开存储
  ~~~

* 【强制】如果存储的字符串长度几乎相等，则使用char定长字符串类型

* 【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000个字符，如果存储长度大于此值，则应定义字段类型为text，独立出来一张表，用主键来对应，避免影响其他字段的索引效率

* 【强制】表必备三个字段，id，update_time，create_time

  ~~~wiki
  说明：其中id必为主键，类型为bigint unsigned，单表时主键自增，步长为1，update_time和create_time字段类型必须为date_time
  ~~~

* 【推荐】表的命名最好遵循"业务名称_表的作用"原则

  ~~~wiki
  正例：alipay_task/froce_project/trade_config 
  ~~~

* 【推荐】库名与应用名称尽量一致

* 【推荐】当修改字段含义或追加字段表示的状态时，需要及时更新字段注释

* 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致性，冗余字段应遵循以下原则

  ~~~wiki
  1)不是频繁修改的字段
  2)不是唯一索引的字段
  3)不是varchar超长字段，更不能是text字段
  正例：各业务线经常冗余存储商品名称，避免查询时需要调用基础服务获取
  ~~~

* 【推荐】当单表行数超过500万或者单表容量超过2GB时，才推荐分库分表

  ~~~wiki
  说明：如果预计三年后的数据量无法达到这个级别，请不要在创建表时就分库分表
  ~~~

* 【参考】设置合适的字符存储长度，不但可以节约数据库表空间和索引存储，更重要的是能够提升检索速度

### 索引规约

* 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引

  ~~~wiki
  说明；不要以为唯一索引影响了insert的速度，这个速度的损耗可以忽略不计，但会明显提高查询速度，另外，即使在应用层做了非常完善的检验控制，只要没有唯一索引，根据墨菲定律，就必然有脏数据产生
  ~~~

* 【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致，当多表关联查询时，保证被关联的字段需要有索引

  ~~~wiki
  说明：即使是双表join，也要注意表索引，SQL性能
  ~~~

* 【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可

  ~~~wiki
  说明：索引的长度与区分度是一对矛盾体，一般对于字符串类型的数据，长度为20的索引，区分度会高达90％以上，可以使用count(distinct left(列名，索引长度))/count(*)的区分度来确定
  ~~~

* 【强制】在页面搜索严禁左模糊或者全模糊，如果需要，那么请通过搜索引擎来解决

  ~~~wiki
  说明：索引文件具有B树的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引
  ~~~

* 【推荐】如果有order by的场景，请注意利用索引的有序性，order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能

  ~~~wiki
  正例：
  where a = ? and b = ? order by c;
  索引:a_b_c
  反例：
  索引中如果存在范围查询，那么索引有序性无法利用，如：where  a > 10 order by c ，索引a_c无法排序
  ~~~

* 【推荐】利用覆盖索引进行查询操作，避免回表

  ~~~wiki
  说明：如果想知道一本书的第11章标题是什么，我们没必要翻开这本书的第11章对应的那一页，只需要浏览一下目录就可以了，这个目录就起到了覆盖索引的作用
  正例：能够建立的索引类型分为主键索引，唯一索引，普通索引三种，而覆盖索引只是查询的一种效果，用explain的结果，extra列会出现"using index"
  ~~~

* 【推荐】利用延迟关联或者子查询优化超多分页的场景

  ~~~wiki
  说明：MySQL并不是跳过offset行，而是返回offset+N行，然后放弃前offset行，返回N行，当offset超大时，效率会非常低，要么控制返回的总页数，要么对超过特定阈值的页面进行SQL改写
  正例：先快速定位需要获取的id段，再关联
  select t1.* from 表1 as t1 ,(select id from 表1 where 条件 limit 100000,20) as t2 where t1.id = t2.id[[
  ~~~

* 【推荐】SQL性能优化的目标，至少达到range级别，要求是ref级别，最好是consts级别

  ~~~wiki
  说明：
  consts级别是指单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据
  ref级别是指使用普通的索引
  range级别是指对索引进行范围检索
  Index级别是指索引物理文件全扫描，速度非常慢，index级别比range级别还低，与全表扫描相比是小巫见大巫
  ~~~

* 【推荐】当建组合索引时，区分度最高的最好在最左边

  ~~~wiki
  说明：如果where a = ? and b = ? ,a列几乎接近唯一值，那么只需要单建idx_a索引
  如果存在非等号和等号混合判断的情况，那么在建立组合索引的时候，请把等号条件的列前置，如：where c > ? and d = ?，即使c的区分度更高，也必须把d放在索引的最前列，即建立组合索引inx_d_c
  ~~~

* 【推荐】防止因字段类型不同造成隐式转换，导致索引失效

* 【参考】当创建索引时，避免如下极端误解

  ~~~wiki
  1)宁滥勿缺，认为一个查询就需要建立一个索引
  2)宁缺毋滥，认为索引会消耗空间，严重拖慢记录的更新及行的新增速度
  3)抵制唯一索引，认为唯一索引一律需要在应用层通过先查后插的方式解决
  ~~~

### SQL语句

* 【强制】不要使用count(列名)或count(常量）来替代count(※)， count(※)是sql92定义的标准统计行数的语法，与数据库无关，与NULL和非NULL无关

  ~~~wiki
  说明：count(*)会统计值为null的行，而count(列名)不会统计此列值为NULL的行
  ~~~

* 【强制】count(distinct colunm)计算该列除NULL外的不重复行数，注意，count(distinct column1，column2)，如果其中一列全为NULL，那么即使另一列有不同的值，返回的结果也是0

* 【强制】当某一列的值全为NULL时，count(column)的返回结果为0，但sum(column)的返回结果为NULL，因此使用sum()时需要注意NPE问题

  ~~~wiki
  正例：可以使用如下方法来避免sum的NPE问题，select ifnull(sum(column)，0) from table 
  ~~~

* 【强制】使用ifnull判断是否为null值

  ~~~wiki
  说明：
  NULL与任何值的直接比较都为NULL
  1)NULL<>NULL的返回结果是NULL，而不是FALSE
  2)NULL=NULL的返回结果是NULL,而不是TRUE
  3)NULL<>1的返回结果是NULL，而不是TRUE
  反例：
  在SQL语句中，如果在NULL前换行，则会降低可读性。select * from table where column1 is null and column3 is not null;
  而ISNULL(column)的执行效率要更高一些
  ~~~

* 【强制】在代码中写分页查询逻辑时，若count为0，则直接返回，避免执行后面的分页语句

* 【强制】不得使用外键与级联，一切外键概念必须在应用层解决

  ~~~wiki
  说明：以学生和成绩的关系为例，学生表中的student_id是主键，成绩表中的student_id是外键，如果更新学生表中的student_id字段，则同时触发成绩表中的student_id更新，即为级联更新，外键与级联更新使用于单机低并发，不适合分布式，高并发集群，级联更新是强阻塞，存在数据库更新风暴的问题，外键影响数据库的插入速度
  ~~~

* 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性

* 【强制】当订正数据(特别是删除或者修改记录操作)时，要先select，避免出现误删除，确认无误后才能执行更新语句

* 【推荐】in操作能避免就避免，若实在避免不了，则需要仔细评估in后面的集合元素数量，控制在1000以内

* 【参考】TRUNCATE TABLE 比DELETE速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句

  ~~~wiki
  说明：TRUNCATE TABLE 在功能上与不带where子句的DELETE语句相同
  ~~~


### ORM映射

* 【强制】在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明

  ~~~wiki
  说明：
  1)增加查询分析器解析成本
  2)增减字段容易与resultMap配置不一致
  3)多余字段增加网络开销，尤其是text类型的字段
  ~~~

* 【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射

  ~~~wiki
  在sql.xml中必须增加映射
  ~~~

* 【强制】不要用resultClass作为返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>，反过来，每个表也必然有一个<resultMap>与之对应

  ~~~wiki
  说明：配置映射关系，使字段与DO类解耦，方便维护
  ~~~

* 【强制】sql.xml配置参数使用：#{}，#param#，不要使用${}，此种方式容易出现sql注入

* 【强制】Mybatis自带的queryForList(Stringstatement Name，int start，int size)不推荐使用

  ~~~wiki
  说明：它的实现方式是在数据库中取到statementName对应的sql语句的所有记录，在通过subList取start，size的子集合
  正例：
  Map<String，object> map = new hashMap<>(16);
  map.put("start",start);
  map.put("size",size);
  ~~~

* 【强制】不允许直接将hashMap和hashTable作为查询结果集的输出

  ~~~wiki
  反例；某工程师为避免写一个<resultMap>，直接使用一个hashTable接收数据库返回的结果，结果由于数据库版本不一致，出现日常把bigint转成Long值，而线上把bigint解析为BigInteger的现象，导致线上出现问题
  ~~~

* 【强制】更新数据库表记录时，必须同时更新记录所对应的修改时间，即update_time字段值为当前时间

* 【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段都进行update table set c1 = value1,c2=  value2, c3 = value3，是不对的，当执行sql时，不要更新无改动的字段，一是容易出错，二是效率低，三是增加binlog存储

* 【参考】@Transational事务不要滥用。事务会影响数据库的QPS，另外，使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚，搜索引擎回滚，消息补偿和统计修正等

* 【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时执行相应的sql语句，<isNotEmpty>表示不为空且不为null时执行，<isNotNull>表示不为NULL时执行

## 阿里巴巴Java开发手册 第五章重点摘录完结

